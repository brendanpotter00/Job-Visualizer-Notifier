# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Job Posting Analytics SPA - A mobile-responsive TypeScript + React application that visualizes job posting activity over time for multiple companies using external ATS (Applicant Tracking System) job board APIs (Greenhouse, Lever, and Ashby).

**Current Status**: Production-ready application with comprehensive refactoring completed. All 5 phases complete:
- ✅ **Phase 1**: Critical architecture refactoring (factory patterns)
- ✅ **Phase 2**: Performance optimizations (memoization, re-render elimination)
- ✅ **Phase 3**: Code quality improvements (constants, validation, logging)
- ✅ **Phase 4**: Component cleanup (decomposition, dead code removal)
- ✅ **Phase 5**: Comprehensive documentation (architecture diagrams, migration guide, JSDoc)

**Key Metrics**: 422+ tests passing, >85% coverage, 600 lines of code removed, zero TypeScript errors.

## Development Commands

### Development
```bash
npm run dev              # Start dev server (Vite) - http://localhost:5173
npm run preview          # Preview production build
```

### Build & Type Checking
```bash
npm run build            # Production build (runs tsc + vite build)
npm run type-check       # TypeScript validation only
```

### Testing
```bash
npm test                 # Run all tests (Vitest)
npm run test:watch       # Run tests in watch mode
npm run test:coverage    # Generate coverage report
npm run test:ui          # Open Vitest UI
```

### Code Quality
```bash
npm run lint             # ESLint
npm run format           # Prettier formatting
```

## Architecture Overview

**Visual Documentation**: See `docs/architecture.md` for comprehensive Mermaid diagrams including:
- High-level data flow (user interaction → Redux → API → UI)
- Redux state shape (complete store structure)
- API client factory pattern (shared logic diagram)
- Filter slice factory pattern (dynamic generation)
- Component hierarchy (full component tree)
- Time bucketing algorithm (detailed flowchart)
- Role classification system (classification flowchart)
- Error handling flow (error propagation)
- Performance optimization patterns (memoization strategy)

### State Management Pattern
- **Redux Toolkit** with feature-based slices (jobs, filters, app, ui)
- **Factory Pattern for Filter Slices**: Both graph and list filter slices generated by `createFilterSlice` factory
  - Eliminates 158 lines of duplication
  - Dynamically generates 25 action creators per slice
  - Ensures consistency across filter implementations
- **Independent Filter Systems**: Graph and list filters operate completely independently with manual sync option
- **Normalized State**: Jobs organized by company ID in `byCompany` map for O(1) lookup
- **Memoized Selectors**: Heavy use of `createSelector` from Reselect for automatic memoization
- **Async Thunks**: `loadJobsForCompany` handles API calls with proper loading/error states
- **Optimized Re-renders**: Components use `useMemo` and `useCallback` to prevent unnecessary re-renders
  - Chart data transformation memoized
  - Bucket job filtering memoized
  - MetricsDashboard: 0 timer-based re-renders (was 60/hour)
  - CompanySelector: Single dispatch pattern (no double API calls)

### Data Flow Pattern
1. User selects company → `loadJobsForCompany` thunk dispatched (single dispatch)
2. Thunk selects appropriate API client via factory pattern (Greenhouse/Lever/Ashby)
3. Base client factory handles fetch, error handling, and validation
4. Raw API response → ATS-specific transformer → Normalized Job model
5. Role classification algorithm runs (keyword-based categorization with confidence scoring)
6. Redux state updates (jobs stored in normalized `byCompany` map + metadata calculated)
7. Memoized selectors filter/transform data for UI (independent graph and list filtering)
8. Components re-render efficiently with filtered/bucketed data (memoized transformations)

**See**: `docs/architecture.md` for complete data flow diagram with all layers visualized.

### API Integration Architecture

**Factory Pattern Implementation:**
- **Base Client Factory** (`src/api/baseClient.ts`): Creates all API clients with shared logic
  - Eliminates 220+ lines of duplication (74 lines → 15 lines per client)
  - Handles 11 common operations: validation, URL building, fetch, error handling, JSON parsing, job extraction, transformation, date filtering, limit filtering, metadata calculation, logging
  - Type-safe with generics for response types and config types
  - Single source of truth for API behavior

**Client Architecture:**
- **Three ATS Providers**: Greenhouse, Lever, Ashby (all using factory pattern)
- **Common Interface**: All clients implement `JobAPIClient` interface
- **ATS-Specific Logic**: Only URL building and response extraction differ per provider
- **Unified Job Model**: All transformers convert to common `Job` type with classification

**Supporting Layers:**
- **Validation Layer** (`src/api/transformers/validation.ts`): Runtime validation with `TransformError` class
  - Validates required fields, type checking
  - Provides clear error messages with field names and data
  - Gracefully handles malformed API responses
- **Error Handling**: Custom `APIError` class distinguishes retryable vs non-retryable errors
  - HTTP 500/503/429: Retryable
  - HTTP 401/403/404: Non-retryable
  - Network errors: Retryable
- **Logging Utility** (`src/utils/logger.ts`): Environment-aware logging
  - Debug logs only in development
  - Consistent format across all clients
  - Ready for integration with external services (Sentry, LogRocket)

**Deployment:**
- **No Backend**: Client-side only, all API calls from browser
- **Public APIs**: Only accesses public job board endpoints

**See**: `docs/architecture.md` for API client factory diagram and `docs/MIGRATION.md` for migration guide.

### Key Technical Patterns

#### Role Classification System

**Location**: `src/utils/roleClassification.ts` and `src/config/roleClassificationConfig.ts`

**Algorithm Overview:**
- Keyword-based classification into 14 categories:
  - **Engineering Roles**: frontend, backend, fullstack, mobile, data, ml, devops, platform, qa, security, graphics, embedded
  - **Generic Tech**: otherTech (fallback)
  - **Non-Technical**: nonTech
- **Confidence Scoring** (0-1): Uses constants from `src/constants/classificationConstants.ts`
  - Base: 0.5 for any match
  - +0.1 per keyword match (capped at 0.85)
  - +0.15 for title matches
  - +0.05 for tech department
  - Max: 0.95 (0.75 for otherTech)
- **Tech Department Patterns**: Regex patterns for identifying engineering/tech departments
- **Exclusion Patterns**: High-confidence (0.9) identification of non-tech roles (recruiter, coordinator, etc.)

**Architecture:**
- **Decomposed Functions**: Main `classifyJobRole` orchestrates 4 helper functions
  - `checkExclusion`: Identifies non-tech roles
  - `findCategoryMatches`: Keyword matching across all categories
  - `selectBestCategory`: Selects category with most matches
  - `calculateConfidence`: Computes confidence score with bonuses
- **Time Complexity**: O(c × k) where c=14 categories, k=~10-20 keywords per category
- **Critical**: Runs on every job during API transformation
- **Comprehensive JSDoc**: All functions documented with examples and cross-references

**See**: `docs/architecture.md` for detailed classification flowchart with confidence scoring table.

#### Time Bucketing Algorithm

**Location**: `src/utils/timeBucketing.ts`

**Purpose**: Groups jobs into time buckets for graph visualization with consistent X-axis spacing.

**Dynamic Bucket Sizing** (uses `src/constants/timeConstants.ts`):
- Short windows (≤24h): Minute-level granularity
  - 30m → 5-minute buckets (6 buckets)
  - 1h → 10-minute buckets (6 buckets)
  - 3h → 30-minute buckets (6 buckets)
  - 6h/12h/24h → 1-hour buckets (6-24 buckets)
- Medium windows (3d-30d): Hour to day granularity
  - 3d → 6-hour buckets (12 buckets)
  - 7d/14d/30d → 1-day or 12-hour buckets (7-30 buckets)
- Long windows (≥90d): Multi-day granularity
  - 90d → 3-day buckets (30 buckets)
  - 180d → 7-day buckets (26 buckets)
  - 1y → 14-day buckets (26 buckets)
  - 2y → 30-day buckets (24 buckets)

**Key Algorithm Features:**
- **Empty Buckets**: Creates buckets for entire range (critical for proper graph spacing)
- **Boundary Alignment**: Buckets align to clean boundaries (top of hour, start of day)
- **Cumulative Counts**: `getCumulativeCounts()` for line graph trends
- **Job ID Storage**: Each bucket stores job IDs for drill-down to modal
- **Bucket Statistics**: `calculateBucketStats()` provides aggregate metrics
- **Time Complexity**: O(n + b) where n = jobs, b = max ~30 buckets
- **Space Complexity**: O(b) for bucket storage
- **Comprehensive JSDoc**: Main function has 40+ line JSDoc with algorithm explanation and examples

**See**: `docs/architecture.md` for complete bucket size mapping table and detailed algorithm flowchart.

#### Redux Selector Patterns
Critical selectors to understand:
- `selectCurrentCompanyJobs`: Gets jobs for currently selected company
- `selectGraphFilteredJobs`: Applies graph filters (time window, software-only, location, department, role category)
- `selectListFilteredJobs`: Applies list filters + search query (independent from graph)
- `selectGraphBucketData`: Combines filtered jobs + time bucketing for chart visualization
- `selectAvailableLocations/Departments/EmploymentTypes`: Dynamic filter options based on current data

**Key Point**: Graph and list selectors are completely independent - changing graph filters does NOT affect the list and vice versa.

### Component Architecture

#### Main Component Structure
```
App.tsx (Redux Provider + MUI ThemeProvider + main layout)
├── CompanySelector (header dropdown)
├── GraphSection (chart + filters)
│   ├── GraphFilters (time window, location, department, role category, software-only)
│   └── JobPostingsChart (Recharts line chart)
├── ListSection (list + filters)
│   ├── ListFilters (search, time window, filters)
│   └── JobList → JobCard (repeated)
└── BucketJobsModal (MUI Dialog, opens on graph point click)
```

#### Important Component Details
- **JobPostingsChart**: Uses Recharts `LineChart`, click handler opens modal via `openGraphModal` action
- **JobCard**: Displays job with MUI Card, chips for metadata, external link handling
- **BucketJobsModal**: Fullscreen on mobile via `useMediaQuery`, reads `ui.graphModal` state
- **CompanySelector**: Auto-loads jobs on company change via `useCompanyLoader` hook (single dispatch, no double loading)

### File Organization Principles
- **Feature-based**: `src/features/{jobs,filters,ui,app}` - each has slice + selectors + thunks
- **API Layer**: `src/api/` - clients + transformers + types + base client factory
- **Utils**: `src/utils/` - pure functions (role classification, time bucketing, date utils, logger)
- **Config**: `src/config/` - static configuration (companies, classification rules, theme)
- **Constants**: `src/constants/` - magic numbers extracted to named constants (time, classification)
- **Types**: `src/types/index.ts` - central type definitions
- **Tests Mirror Structure**: `src/__tests__/` follows same structure as `src/`
- **Documentation**: `docs/` - architecture diagrams and migration guides

## Common Development Tasks

### Adding a New Company
1. Edit `src/config/companies.ts`
2. Add company config with ATS type (greenhouse/lever/ashby)
3. No code changes needed - system automatically uses correct client via factory pattern

### Adding a New ATS Provider
1. Create transformer function in `src/api/transformers/[provider]Transformer.ts`
2. Create client using factory pattern (~15 lines):
   ```typescript
   export const newATSClient = createAPIClient<NewATSResponse, NewATSConfig>({
     name: 'NewATS',
     buildUrl: (config) => `${config.apiBaseUrl}/jobs`,
     extractJobs: (response) => response.jobs,
     transformer: transformNewATSJob,
     validateConfig: (config): config is NewATSConfig => config.type === 'newats',
   });
   ```
3. Add to company configs and client selection logic
4. Write tests for transformer
5. See `docs/MIGRATION.md` for detailed guide

### Modifying Role Classification
1. Edit keyword mappings in `src/config/roleClassificationConfig.ts`
2. Update `categoryKeywords`, `techDepartments`, or `exclusionPatterns`
3. Run tests: `npm test -- roleClassification.test.ts`
4. Classification runs automatically during API transformation

### Adding New Filters
1. Add filter field to `GraphFilters` or `ListFilters` type in `src/types/index.ts`
2. Update `createFilterSlice` factory in `src/features/filters/createFilterSlice.ts` to generate new actions
3. Update filtering logic in `src/features/filters/filtersSelectors.ts`
4. Add UI control in `src/components/filters/GraphFilters.tsx` or `ListFilters.tsx`
5. Write tests in `src/__tests__/features/filters/`
6. Both graph and list slices will automatically get new actions via factory pattern

### Debugging Data Flow
1. Check Redux DevTools for state shape
2. Use selector tests to verify filtering logic
3. Check API transformer tests for data normalization
4. Verify time bucketing output with bucketing tests
5. Look at component tests for UI integration

## Testing Architecture

**Total Tests**: 422+ passing (comprehensive coverage across all layers)

### Test Categories
- **Store**: Redux store initialization
- **Role Classification**: Keyword detection, confidence scoring (35+ tests)
- **API Layer**: Base client factory, transformers for all ATS providers (Greenhouse, Lever, Ashby)
- **Redux Slices**: Jobs + filters reducers + selectors + factory patterns
- **Time Bucketing**: Bucket algorithm, edge cases
- **UI Components**: All major components with comprehensive interaction tests
- **Filter Slice Factory**: Tests for `createFilterSlice` factory pattern
- **Utilities**: Date utils, location utils, logging, validation

### Testing Utilities
- **MSW**: Mock Service Worker for API mocking (not yet used, plan for integration tests)
- **Testing Library**: React Testing Library for component tests
- **Vitest**: Test runner with coverage

### Running Specific Tests
```bash
npm test -- roleClassification.test.ts    # Run single file
npm test -- -t "classifies frontend"      # Run tests matching pattern
npm test -- --coverage                     # Coverage report
```

## Critical Implementation Details

### Type Safety
- **Strict TypeScript**: No `any` types allowed (enforced by tsconfig.json)
- **Type Inference**: Heavy use of type inference from RTK
- **Type Guards**: Used in transformers for ATS-specific logic
- **Zero Type Errors**: `npm run type-check` must always pass

### API Rate Limiting
- **None Currently Implemented**: Public APIs have no documented rate limits
- **Future**: Consider exponential backoff in APIError handling
- **Caching**: Per-company caching in Redux prevents unnecessary refetches

### Performance Considerations
- **Memoization**: All selectors use `createSelector` for automatic memoization
- **Component Optimization**: Chart data transformation wrapped in `useMemo`, bucket job filtering memoized
- **No Timer Re-renders**: MetricsDashboard uses deterministic calculations (no 60s interval updates)
- **Single Dispatch**: CompanySelector fixed to prevent double API calls
- **Large Datasets**: Tested with 1000+ jobs
- **Bucket Count**: Max ~30 buckets per time window (optimized algorithm)
- **Re-renders**: Selectors prevent unnecessary re-renders by reference equality
- **Selector Patterns**: Proper parameterized selectors (no factory anti-patterns)
- **See**: `docs/architecture.md` for detailed performance optimization diagrams

### Time Handling
- **All Timestamps ISO 8601**: Stored as strings in format `2025-11-20T10:30:00Z`
- **date-fns**: Used for all date formatting and manipulation
- **Timezone**: All times handled in UTC, displayed in local timezone
- **Bucket Boundaries**: Inclusive start, exclusive end

## Known Limitations & Gotchas

1. **Client-Side Only**: No backend means no caching, rate limiting, or private API access
2. **Public APIs Only**: Can only access public job boards (Greenhouse board token, Lever/Ashby company postings)
3. **No RTK Query**: Manual fetch implementation with factory pattern (migration path available)
4. **Graph Filter Independence**: Graph and list filters are separate by design - manual sync available via button
5. **Empty Buckets Matter**: Time bucketing creates empty buckets for full range - don't filter them out
6. **Role Classification is Heuristic**: Not perfect, confidence scoring helps identify uncertain classifications
7. **Factory Patterns**: When modifying filter or API client logic, update the factory functions, not individual implementations

## Future Migration Path

### RTK Query (Documented in IMPLEMENTATION.md)
- Keep existing clients + transformers unchanged
- Replace thunks with `createApi` endpoints
- Use generated hooks (`useGetGreenhouseJobsQuery`)
- Benefits: automatic caching, request deduplication, refetching

### Planned Enhancements (see README.md)
- Email notifications for new postings
- Job comparison features
- Export to CSV/Excel
- Dark mode support
- Saved filter presets

## Important Files Reference

| Concept | Primary File(s) |
|---------|----------------|
| **Architecture Documentation** | `docs/architecture.md` (Mermaid diagrams) |
| **Migration Guide** | `docs/MIGRATION.md` |
| Redux Store Config | `src/app/store.ts` |
| Type Definitions | `src/types/index.ts` |
| Company Config | `src/config/companies.ts` |
| **API Client Factory** | `src/api/baseClient.ts` (creates all clients) |
| API Clients | `src/api/greenhouseClient.ts`, `leverClient.ts`, `ashbyClient.ts` |
| API Transformers | `src/api/transformers/{greenhouse,lever,ashby}Transformer.ts` |
| **Validation Layer** | `src/api/transformers/validation.ts` |
| **Filter Slice Factory** | `src/features/filters/createFilterSlice.ts` (creates both slices) |
| Filter Slices | `src/features/filters/{graph,list}FiltersSlice.ts` |
| Filter Selectors | `src/features/filters/filtersSelectors.ts` |
| Jobs State | `src/features/jobs/jobsSlice.ts`, `jobsSelectors.ts`, `jobsThunks.ts` |
| UI State | `src/features/ui/uiSlice.ts` |
| Role Classification | `src/utils/roleClassification.ts`, `src/config/roleClassificationConfig.ts` |
| Time Bucketing | `src/utils/timeBucketing.ts` |
| **Time Constants** | `src/constants/timeConstants.ts` |
| **Classification Constants** | `src/constants/classificationConstants.ts` |
| **Logger Utility** | `src/utils/logger.ts` |
| Main App | `src/app/App.tsx` |
| Graph Component | `src/components/JobPostingsChart/JobPostingsChart.tsx` |
| List Component | `src/components/JobList/JobList.tsx`, `JobCard.tsx` |
| Modal | `src/components/BucketJobsModal/BucketJobsModal.tsx` |

## Refactoring Benefits (Completed)

The application has undergone comprehensive refactoring with measurable improvements:

**Code Reduction:**
- API clients: 220+ lines eliminated (74 → 15 lines per client, -80%)
- Filter slices: 158 lines eliminated (161 → 15 lines per slice, -91%)
- Total: ~600 lines removed while adding functionality

**Performance Improvements:**
- MetricsDashboard re-renders: 60/hour → 0 (-100%)
- CompanySelector API calls: 2 → 1 per company change (-50%)
- Chart data transformations: Every render → Only on data change (memoized)
- Bucket job filtering: Every render → Only on prop change (memoized)
- Selector patterns: Fixed factory anti-patterns, proper memoization maintained

**Code Quality Enhancements:**
- Magic numbers → Named constants (all time and classification values)
- No validation → Runtime validation layer with clear error messages
- Console statements → Environment-aware logger (production-safe)
- Type violations → Zero `any` types, strict TypeScript compliance
- 119-line function → Decomposed into helper functions with single responsibilities

**Testing & Coverage:**
- Test count: 140 → 422+ (+282 tests, +201% increase)
- Coverage: ~70% → >85% (+15%)
- New test categories: Factory patterns, validation, logging, utilities

**Documentation:**
- 9 comprehensive Mermaid diagrams (data flow, state shape, factories, algorithms)
- 47KB of new documentation (architecture.md + MIGRATION.md)
- 350+ lines of JSDoc added to complex functions
- Complete migration guide with before/after comparisons

**Maintainability:**
- Adding ATS provider: 74 lines → 15 lines (~20% of previous effort)
- Adding filter type: Manual duplication in 2 files → Update factory once
- Bug fixes: Fix once in factory → Applies to all implementations
- Onboarding: Visual diagrams and comprehensive docs accelerate understanding

## Development Workflow Notes

- **Zero TypeScript Errors Required**: Run `npm run type-check` before committing
- **Test Coverage**: Maintain >85% coverage (check with `npm run test:coverage`)
- **Strict ESLint**: Follow existing patterns, no warnings tolerated
- **Prettier Formatting**: Auto-format with `npm run format`
- **Feature Branch Development**: See README.md Contributing section
- **Factory Pattern First**: When modifying API or filter logic, always update the factory, not individual implementations
- **Documentation References**:
  - Architecture diagrams: `docs/architecture.md` (9 Mermaid diagrams)
  - Migration guide: `docs/MIGRATION.md` (before/after comparisons)
  - Refactoring plan: `.claude/plans/happy-sprouting-pumpkin.md` (historical reference)

## API Documentation References

- **Greenhouse Job Board API**: https://developers.greenhouse.io/job-board.html
- **Lever Postings API**: https://github.com/lever/postings-api

## Troubleshooting

### TypeScript Errors
Run `npm run type-check` to see detailed errors. Most common issues:
- Missing type imports from `src/types/index.ts`
- Incorrect selector return types (check with Redux DevTools)
- Transformer type mismatches (verify ATS response types in `src/api/types.ts`)

### Test Failures
- Check test isolation (each test should be independent)
- Verify mock data matches expected types
- Use `npm run test:ui` for visual debugging
- Check that selectors use correct state shape

### Dev Server Issues
```bash
lsof -ti:5173 | xargs kill -9    # Kill process on port 5173
npm run dev                       # Restart server
```

### Build Errors
```bash
rm -rf node_modules package-lock.json
npm install
npm run build
```
